### Buffer Overflow 1

#### Question Description:

*Okay now you're cooking! This time can you overflow the buffer and return to the flag function in this [program](https://github.com/Eunseo-Lee/Computer-Journey/blob/master/CTF%20Writeup/2018/PicoCTF%202018/Binary%20Exploitation/Buffer%20Overflow%201/Attachments/vuln)? You can find it in /problems/buffer-overflow-1_0_787812af44ed1f8151c893455eb1a613 on the shell server. [Source.](https://github.com/Eunseo-Lee/Computer-Journey/blob/master/CTF%20Writeup/2018/PicoCTF%202018/Binary%20Exploitation/Buffer%20Overflow%201/Attachments/vuln.c)*

#### Hints:
*1. This time you're actually going to have to control that return address!*

*2. Make sure you consider Big Endian vs Little Endian.*

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━▲━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

It looks like we have to overwrite the return address this time, unlike the last problem (buffer overflow 0). 


`
vuln: setgid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Li
nux 2.6.32, BuildID[sha1]=5235698279b65da569a42e74772f0d7f3057f8b8, not stripped
`

The program file is a 32-bit ELF that asks for user input. 
![screenshot1](https://github.com/Eunseo-Lee/Computer-Journey/blob/master/CTF%20Writeup/2018/PicoCTF%202018/Binary%20Exploitation/Buffer%20Overflow%201/Screenshots/test.PNG)

After our input, the program returns an interesting text: 
`Okay, time to return... Fingers Crossed... Jumping to 0x80486b3`

Im guessing that we need to overflow the buffer when the program asks us for our input, then change the return address of the buffer somewhere else... But in order to be sure, lets take a look at the [source code](https://github.com/Eunseo-Lee/Computer-Journey/blob/master/CTF%20Writeup/2018/PicoCTF%202018/Binary%20Exploitation/Buffer%20Overflow%201/Attachments/vuln.c). 

Long in short, the program has two functions called vuln() and win() that we need to utilize in order to get the flag. 

After the main() function prints out the message for user input, it calls the vuln() function. The vuln() function has a buffer that stores the user input with the function get(). The win() function simply prints out the flag, but we can't access it directly. 

So, how do we access the win() function with only vuln()??

The vuln() has a buffer overflow vulnerability in which allows us to overflow the buffer that contains the user input. 

```
void vuln(){                                                                                                               
  char buf[BUFSIZE];                                                                                                       
  gets(buf);                                                                                                               
                                                                                                                           
  printf("Okay, time to return... Fingers Crossed... Jumping to 0x%x\n", get_return_address());                            
}
```

The gets() function is a function that is used to scan a line of text from stdin (standard input), and store it in the variable. The function *only* stops when it comes across a newline character. That means we can continue to feed the program our input until the buffer overflows, as long as our input doesn't contain a newline character! 

In order to jump to the win() function, we need to know the address of win(), and the buffer length to overwrite the return address. 

Lets run gdb (GNU Debugger) and find out all the information we need for overflow. 

```
GNU commands:
gdb -q ./vuln
b(reak) *main
r(un)
i(nfo) addr(ess) vuln
p(rint) vuln
```

I set the breakpoint for function main() and ran the program so I could find out the address for vuln(). The last two commands are two different ways to find out the address of a symbol or expression. The brackets are added for readability, and it does not matter if you enter the full command or the shortened version in gdb. We can also find out the address of vuln() with `objdump`, but we will stick to gdb. 

```
Symbol "vuln" is at 0x804862f in a file compiled without debugging.
$1 = {<text variable, no debug info>} 0x804862f <vuln>
```

It looks like vuln() is located in 0x804862f. Now let's find out the buffer length so we can overwrite the return address. 

