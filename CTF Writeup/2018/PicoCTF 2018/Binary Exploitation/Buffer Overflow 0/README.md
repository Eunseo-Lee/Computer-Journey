### Buffer Overflow 0

#### Question Description:

*Let's start off simple, can you overflow the right buffer in this [program 1](https://github.com/Eunseo-Lee/Computer-Journey/blob/master/CTF%20Writeup/2018/PicoCTF%202018/Binary%20Exploitation/Buffer%20Overflow%200/Attachments/vuln)  to get the flag?
You can also find it in /problems/buffer-overflow-0_3_d5263c5219b334339c34ac35c51c4a17 on the shell server. [Source 2](https://github.com/Eunseo-Lee/Computer-Journey/blob/master/CTF%20Writeup/2018/PicoCTF%202018/Binary%20Exploitation/Buffer%20Overflow%200/Attachments/vuln.c).*

#### Hints:
*1. How can you trigger the flag to print?*

*2. If you try to do the math by hand, maybe try and add a few more characters. Sometimes there are things you aren't expecting.*

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━▲━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

First things first, lets check the file type of the binary we have to exploit. Maybe in easy CTF problems this may not be important, but it's good to make it a habit :) 

`
vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=3c23f3fef9b2b4bb59ed1f22517ad56788afc686, not stripped
 `
 
After running the command `file vuln`, we see that the file is an ELF (Executable and Linkable) 32-bit file. ELF files are used commonly in Unix-based OS, and 32-bit binaries are usually easier to buffer-overflow than 64-bit binaries due to the differences in calling conventions, but that's for another time. 

Let's take a look at the [source code](https://github.com/Eunseo-Lee/Computer-Journey/blob/master/CTF%20Writeup/2018/PicoCTF%202018/Binary%20Exploitation/Buffer%20Overflow%200/Attachments/vuln.c). 

There are three functions running in total: sigsegv_handler(), vuln() and main(). 

The sigsegv_handler() is a function that gets called *only* if a segmentation fault happens, which is achieved by using the `system()` library function in C. Segmentation faults is a failure that's raised by the program when restricted memory (aka 'forbidden') is accessed. Simply speaking, this failure will only happen if we go to memory that we aren't allowed to access... 

Well, how do we do that? 

The vuln() function looks suspicious, so let's see what that does. 

`
void vuln(char *input){
  char buf[16];
  strcpy(buf, input);
}
`

The vuln() function gives us a buffer of 16 bytes, and takes in an input parameter. Then, the input parameter is copied to the buffer by using the `strcpy()` function. 
Wait! What does strcpy() do? 

`char* strcpy(char* dest, const char* src);`

strcpy() takes in a destination pointer that points to the file where the contents are copied into, and a string that is to be copied. But... there are no restrictions as to *how much* the function wants to copy. This means that we can copy a string, no matter how long, into our buffer. 

There are only 16 bytes that our buffer can hold. What will happen if we copy more than 16 bytes into our buffer, since there are no restrictions? 

Whatever text we enter after running 'vuln' will be taken in by the program as an input to the buffer. Let's try putting in random text that's longer than 

`./vuln AAAAAAAAAAAAAAAAAAAAAAAAAAAA`

I found that the flag is shown after 28 bytes. 
It looks like calculation isn't necessary in this problem. We don't have to overwrite the retuurn address, or worry about getting the right buffer length. We just need a segmentation fault. 

##### Flag: picoCTF{ov3rfl0ws_ar3nt_that_bad_********}
